#pragma kernel Main
#pragma kernel Merge
#pragma kernel RenderCascade
#pragma kernel MergeCascades


#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GlobalSamplers.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Common.hlsl"

static float StepSize = 1;
static int ProbeSize = 10;
static int StepsCount0 = ProbeSize;
static int StepsCount1 = ProbeSize * 2;
static int StepsCount2 = ProbeSize * 4;

float4 _RadianceCascades_TexelSize;
float4 _CascadeRect;
RWTexture2D<float4> _RadianceCascades;

RWTexture2D<float4> _Cascade0;
RWTexture2D<float4> _Cascade1;
RWTexture2D<float4> _Cascade2;
RWTexture2D<float4> _Cascade3;
RWTexture2D<float4> _Cascade4;
RWTexture2D<float4> _Cascade5;

int2 calculateRange(int cascadeLevel)
{
    const float factor = 4.0;

    float start = (1.0 - pow(factor, cascadeLevel)) / (1.0 - factor);
    float end = (1.0 - pow(factor, cascadeLevel + 1.0)) / (1.0 - factor);

    return int2(start, end);
}

float _ProbeSize;
float _CascadeLevel;
float4 _CascadeBufferSize;
RWTexture2D<float4> _OutCascade;

[numthreads(8,8,1)]
void RenderCascade(uint3 id : SV_DispatchThreadID)
{
    uint2 coords = id.xy;
    if (any(coords > uint2(_CascadeBufferSize.xy)))
    {
        return;
    }

    float2 probeCenterUV = (floor(coords / _ProbeSize) * _ProbeSize + 0.5f * _ProbeSize) * _CascadeBufferSize.zw;

    int2 coordsInCascade = fmod(coords, _ProbeSize);

    float angleStep = TWO_PI / (_ProbeSize * _ProbeSize);
    float angle = (coordsInCascade.x + coordsInCascade.y * _ProbeSize) * angleStep;
    angle += angleStep * 0.5f;
    float2 ray;
    sincos(angle, ray.y, ray.x);

    // NOTE: Scale ray to [0; 1] range
    ray *= _CascadeBufferSize.zw;

    int2 cascadeRange = calculateRange(_CascadeLevel) * 2;

    // Offseting center
    probeCenterUV += ray * cascadeRange.x; //_ProbeSize * (_CascadeLevel > 0.5f);

    float sceneDepth = SampleLinearDepth(probeCenterUV) - 0.001f;
    int stepsCount = floor(_ProbeSize * (_CascadeLevel + 1));
    stepsCount = cascadeRange.y - cascadeRange.x;
    _OutCascade[coords] = RayTrace(probeCenterUV, ray, sceneDepth, stepsCount);
}


/////////////
/// MERGE ///
/////////////

static const int Cascade0Size = 2;

float _LowerCascadeLevel;
Texture2D _UpperCascade;
RWTexture2D<float4> _LowerCascade;


//This function findes the 4 nearest angles in the upperProbe to the given angle, and average the values
float4 AverageNearbyAngles(int2 coords, float angle)
{
    int upperCascadeDim = Cascade0Size * pow(2, _LowerCascadeLevel + 1);

    //Transform the angle to an index value inside the upperCascade
    float angleStep = (2 * PI) / (float)(upperCascadeDim * upperCascadeDim);
    int index = AngleToIndex(angle - angleStep / 2, upperCascadeDim);
    //We subtract a small offset to get a correct index value
    //You can try to remove it and you will see the difference

    int2 angle1Position = coords + IndexToCoords(index - 1, upperCascadeDim);
    int2 angle2Position = coords + IndexToCoords(index, upperCascadeDim);
    int2 angle3Position = coords + IndexToCoords(index + 1, upperCascadeDim);
    int2 angle4Position = coords + IndexToCoords(index + 2, upperCascadeDim);
    //IndexToCoords() here reconstruct the 2D coords from the 1D index

    //Finally sampling and averaging
    float4 dir1 = _UpperCascade[angle1Position];
    float4 dir2 = _UpperCascade[angle2Position];
    float4 dir3 = _UpperCascade[angle3Position];
    float4 dir4 = _UpperCascade[angle4Position];

    return (dir1 + dir2 + dir3 + dir4) * 0.25;
}

// This function take the averaged angles from the 4 nearby probes (in the upper cascade) and
// interpolate between them based on the position of the lower probe (in the lower cascade)
float4 SampleNearbyProbes(int2 coords, float angle)
{
    // Calculating dimensions
    int lowerCascadeDim = Cascade0Size * pow(2, _LowerCascadeLevel);
    int upperCascadeDim = Cascade0Size * pow(2, _LowerCascadeLevel + 1);

    //Calculate the position of the center of the lower probe
    int2 lowerCascadeIndex = floor(coords / lowerCascadeDim);
    int2 lowerCascadeCenterPos = lowerCascadeIndex * lowerCascadeDim + (lowerCascadeDim / 2);

    //Calculate the position of bottom-left upper probe
    //(there is 4 upper probes surrounding the lower probe: bottom-left, bottom-right, top-left, top-right)
    //(this code gets the position of the bottom-left one)
    int2 upperCascadeIndex = floor((lowerCascadeIndex - 0.5) / 2.0);
    int2 upperCascadeOriginPos = upperCascadeIndex * upperCascadeDim;
    int2 upperCascadeCenterPos = upperCascadeOriginPos + upperCascadeDim / 2;

    // Since we know the position of the bottom-left probe, the others can be reached just with adding a simple offset
    // the function AverageNearbyAngles() will take care of the rest and find the 4 nearest angle to the one we want and averge them
    float4 rad1 = AverageNearbyAngles(upperCascadeOriginPos + int2(0, 0), angle);
    float4 rad2 = AverageNearbyAngles(upperCascadeOriginPos + int2(upperCascadeDim, 0), angle);
    float4 rad3 = AverageNearbyAngles(upperCascadeOriginPos + int2(0, upperCascadeDim), angle);
    float4 rad4 = AverageNearbyAngles(upperCascadeOriginPos + int2(upperCascadeDim, upperCascadeDim), angle);

    float2 weight = (lowerCascadeCenterPos - upperCascadeCenterPos) / float(upperCascadeDim);
    // the weight have exactly 4 possible values : (0.25, 0.25), (0.25, 0.75), (0.75, 0.25), (0.75, 0.75)
    // it's the relative position of the lower probe in the 4 upper probes

    // Then we bilinearly interpolate between them
    float4 m1 = lerp(rad1, rad2, weight.x);
    float4 m2 = lerp(rad3, rad4, weight.x);

    float4 radiance = lerp(m1, m2, weight.y);

    return radiance;
}


[numthreads(8,8,1)]
void MergeCascades(uint3 id : SV_DispatchThreadID)
{
    uint2 coords = id.xy;
    if (any(coords > uint2(_CascadeBufferSize.xy)))
    {
        return;
    }

    float4 radiance = _LowerCascade[coords]; // Radiance from lower cascade
    if (radiance.a < 0.5f)
    {
        _LowerCascade[id.xy] = radiance;
        return;
    }

    float cascadeDim = Cascade0Size * pow(2, _LowerCascadeLevel);
    int2 coordsInCascade = fmod(coords, cascadeDim);
    float angleStep = TWO_PI / (cascadeDim * cascadeDim);
    float angle = (coordsInCascade.x + coordsInCascade.y * cascadeDim) * angleStep;
    angle += angleStep * 0.5f;

    //After getting the angle we then sample the 4 nearby probes in the upper cascade in that angle (or direction as other say)
    float4 upperRadiance = SampleNearbyProbes(coords, angle);

    //Finally we compose the radiance we calculated from the upper cascade and the radiance from lower one
    radiance.rgb += upperRadiance.rgb * radiance.a;
    radiance.a *= upperRadiance.a;

    _LowerCascade[id.xy] = radiance;
}


// TODO: clip space tracing?
float4 RayTrace3d(float3 probeUV, float3 direction, float sceneDepth, int stepsCount)
{
    direction.xy *= _ColorTexture_TexelSize.zw * StepSize;
    for (int i = 1; i < stepsCount; i++)
    {
        float3 offset = i * direction;

        float2 uv = probeUV + offset;
        if (any(uv < 0) || any(uv > 1))
        {
            return half4(0.0f, 0.0f, 0.0f, 0.0f);
        }

        float currentDepth = SampleLinearDepth(uv);
        // Intersection
        // (0)----------------| scene depth
        // (1)----------|     | current depth
        //              |     |
        if (sceneDepth > currentDepth && sceneDepth - currentDepth < .2f)
        {
            float3 color = SAMPLE_TEXTURE2D_LOD(_ColorTexture, sampler_LinearClamp, uv, 0).rgb;
            color *= dot(color, 1.0f) > 0.2f;
            return float4(color.rgb, 1.0f);
        }
    }

    return half4(0.0f, 0.0f, 0.0f, 0.0f);
}


float4 Test(int2 texCoord, int cascadeIndex, int startStep, int stepCount)
{
    cascadeIndex += 1;
    float probeSize = pow(2, cascadeIndex);
    float2 probeCenterUV = (floor(texCoord / probeSize) * probeSize + probeSize * 0.5f) / _CascadeRect.zw;

    float sceneDepth = SampleLinearDepth(probeCenterUV) - 0.05f;
    // half3 normalWS = SAMPLE_TEXTURE2D_LOD(_NormalsTexture, sampler_PointClamp, probeCenterUV, 0);
    // half3 tangent = cross(normalWS, half3(0, 1, 0));
    // half3 bitangent = cross(normalWS, tangent);

    // Cascade 0
    float sectorId = texCoord.x % probeSize + (texCoord.y % probeSize) * probeSize;
    float2 direction0;
    sincos((sectorId + 0.5f) * PI * 0.5f / pow(4, cascadeIndex - 1), direction0.y, direction0.x);
    direction0 = normalize(direction0);
    return RayTrace(
        probeCenterUV + direction0 / _CascadeRect.zw * StepSize * startStep,
        direction0,
        sceneDepth,
        stepCount
    );
}

// Cascade 0
[numthreads(8,8,1)]
void Main(uint3 id : SV_DispatchThreadID)
{
    uint2 texCoord = id.xy;
    if (any(texCoord > uint2(_CascadeRect.zw)))
    {
        return;
    }
    float2 probeCenterUV;
    float sceneDepth;
    float sectorId;

    // [0; 1]
    #if 0
    probeCenterUV = (floor(texCoord * 0.5f) * 2.0f + 1.0f) / _CascadeRect.zw;

    sceneDepth = SampleLinearDepth(probeCenterUV) - 0.05f;
    // half3 normalWS = SAMPLE_TEXTURE2D_LOD(_NormalsTexture, sampler_PointClamp, probeCenterUV, 0);
    // half3 tangent = cross(normalWS, half3(0, 1, 0));
    // half3 bitangent = cross(normalWS, tangent);

    // Cascade 0
    sectorId = texCoord.x % 2 + (texCoord.y % 2) * 2;
    float2 direction0;
    sincos((sectorId + 0.5f) * PI * 0.5f, direction0.y, direction0.x);
    direction0 = normalize(direction0);
    float4 cascade0 = RayTrace(
        probeCenterUV,
        direction0,
        sceneDepth,
        StepsCount0
    );
    _Cascade0[texCoord] = cascade0;
    #else

    int steps = 8;
    _Cascade0[texCoord] = Test(texCoord, 0, 0, steps);
    int overlap = 3;
    _Cascade1[texCoord] = Test(texCoord, 1, steps - overlap, steps + overlap);
    steps *= 2;
    _Cascade2[texCoord] = Test(texCoord, 2, steps - overlap, steps + overlap);
    steps *= 2;
    _Cascade3[texCoord] = Test(texCoord, 3, steps - overlap, steps + overlap);
    steps *= 2;
    _Cascade4[texCoord] = Test(texCoord, 4, steps - overlap, steps + overlap);
    steps *= 2;
    _Cascade5[texCoord] = Test(texCoord, 5, steps - overlap, steps + overlap);
    return;
    #endif

    // Cascade 1
    probeCenterUV = (floor(texCoord * 0.25f) * 4.0f + 2.0f) / _CascadeRect.zw;
    sceneDepth = SampleLinearDepth(probeCenterUV) - 0.05f;

    float2 direction1;
    sectorId = texCoord.x % 4 + (texCoord.y % 4) * 4;
    sincos((sectorId + 0.5f) * PI * 0.5f * 0.25f, direction1.y, direction1.x);
    direction1 = normalize(direction1);

    _Cascade1[texCoord] = RayTrace(
        probeCenterUV + direction1 / _CascadeRect.zw * StepSize * (StepsCount0),
        direction1,
        sceneDepth,
        StepsCount1
    );

    // TODO: Cascade 2
    probeCenterUV = (floor(texCoord * 0.125f) * 8.0f + 2.0f) / _CascadeRect.zw;
    sceneDepth = SampleLinearDepth(probeCenterUV) - 0.05f;

    float2 direction2;
    sectorId = texCoord.x % 8 + (texCoord.y % 8) * 8;
    sincos((sectorId + 0.5f) * PI * 0.125f * 0.25f, direction2.y, direction2.x);
    direction2 = normalize(direction2);

    _Cascade2[texCoord] = RayTrace(
        probeCenterUV + direction2 / _CascadeRect.zw * StepSize * (StepsCount0 + StepsCount1),
        direction2,
        sceneDepth,
        StepsCount2
    );


    // TODO: Cascade 3
    probeCenterUV = (floor(texCoord * 0.125f) * 8.0f + 2.0f) / _CascadeRect.zw;
    sceneDepth = SampleLinearDepth(probeCenterUV) - 0.05f;

    float2 direction3;
    sectorId = texCoord.x % 8 + (texCoord.y % 8) * 8;
    sincos((sectorId + 0.5f) * PI * 0.125f * 0.25f * 0.25f, direction3.y, direction3.x);
    direction2 = normalize(direction2);

    _Cascade3[texCoord] = RayTrace(
        probeCenterUV + direction3 / _CascadeRect.zw * StepSize * (StepsCount0 + StepsCount1 + StepsCount2),
        direction2,
        sceneDepth,
        StepsCount2
    );
}


/////////////
/// MERGE ///
/////////////

half4 SampleProbe1(uint2 coord, int dim)
{
    int2 probId = floor(coord / dim) * dim;
    half4 color = 0.0h;
    UNITY_UNROLL
    for (int i = 0; i < 4; i++)
    {
        int2 offset = int2(i % 2, i / 2);
        half4 sample = LOAD_TEXTURE2D(_RadianceCascades, probId + offset);

        if (sample.a < 0.5f)
        {
            int2 coordNext = coord;
            coordNext.x += _CascadeRect.z;
            sample += SampleProbe1(coordNext, dim * 2);
        }

        color += sample * 0.25f;
    }

    return color;
}

half4 SampleProbe0(uint2 coord, int dim)
{
    int2 probId = floor(coord / dim) * dim;
    half4 color = 0.0h;
    UNITY_UNROLL
    for (int i = 0; i < 4; i++)
    {
        int2 offset = int2(i % 2, i / 2);
        half4 sample = LOAD_TEXTURE2D(_Cascade0, probId + offset);

        if (sample.a < 0.5f)
        {
            sample += SampleProbe1(coord, dim * 2);
        }
        color += sample * 0.25f;
    }

    return color;
}

half4 SampleProbe(uint2 coord)
{
    int2 probId0 = floor(coord / 2) * 2;
    half4 color = 0.0h;

    // UNITY_UNROLL
    for (int ray0 = 0; ray0 < 4; ray0++)
    {
        // int ray0 = coord.x % 2 + (coord.y % 2) * 2;
        int2 offset0 = int2(ray0 % 2, ray0 / 2);
        half4 s0 = LOAD_TEXTURE2D(_Cascade0, probId0 + offset0);

        if (s0.a < 0.5h)
        {
            s0 = 0;
            // Continue sampler along ray!
            int2 probId1 = floor(coord / 4) * 4;
            for (int i1 = 0; i1 < 4; i1++)
            {
                int ray1 = ray0 * 4 + i1;
                int2 offset1 = int2(ray1 % 4, ray1 / 4);
                half4 s1 = LOAD_TEXTURE2D(_Cascade1, probId1 + offset1);

                if (s1.a < 0.5h)
                {
                    s1 = 0;
                    int2 probId2 = floor(coord / 8) * 8;
                    for (int i2 = 0; i2 < 4; i2++)
                    {
                        int ray2 = ray1 * 4 + i2;
                        int2 offset2 = int2(ray2 % 8, ray2 / 8);
                        half4 s2 = LOAD_TEXTURE2D(_Cascade2, probId2 + offset2);

                        if (s2.a < 0.5f)
                        {
                            s2 = 0;
                            int2 probId3 = floor(coord / 16) * 16;
                            for (int i3 = 0; i3 < 4; i3++)
                            {
                                int ray3 = ray2 * 4 + i3;
                                int2 offset3 = int2(ray3 % 16, ray3 / 16);
                                half4 s3 = LOAD_TEXTURE2D(_Cascade3, probId3 + offset3);

                                // Cascade
                                if (s3.a < 0.5f)
                                {
                                    s3 = 0;
                                    int2 probId4 = floor(coord / 32) * 32;
                                    for (int i4 = 0; i4 < 4; i4++)
                                    {
                                        int ray4 = ray3 * 4 + i4;
                                        int2 offset4 = int2(ray4 % 32, ray4 / 32);
                                        half4 s4 = LOAD_TEXTURE2D(_Cascade3, probId4 + offset4);
                                        s3 += s4;
                                    }
                                }

                                s2 += s3 * 0.25f;
                            }
                        }

                        s1 += s2 * 0.25f;
                    }
                }

                s0 += s1 * 0.25f;
            }
        }
        color += s0 * 0.25f;
    }
    return color;
}

[numthreads(8,8,1)]
void Merge(uint3 id : SV_DispatchThreadID)
{
    uint2 texCoord = id.xy;
    if (any(texCoord > uint2(_CascadeRect.zw)))
    {
        return;
    }

    // _Cascades0[texCoord] = SampleProbe0(texCoord, 2);
    // BUB: Oversampling, i can use target texture twice lower res (cus probe is 2x2)
    _Cascade0[texCoord] = SampleProbe(texCoord);
}
