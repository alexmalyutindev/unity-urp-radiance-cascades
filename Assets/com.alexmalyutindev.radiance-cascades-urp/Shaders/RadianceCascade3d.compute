#pragma kernel RenderCascade
#pragma kernel MergeCascade

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Common.hlsl"

// Layout:
// .______________.
// | +X | +Y | +Z |
// |____|____|____|
// | -X | -Y | -Z |
// |____|____|____|
RWTexture2D<float4> _OutCascade;
int2 _ProbesCount;

float _ProbeSize;
float _CascadeLevel;
float4x4 _View;
float4x4 _ViewProjection;
float4x4 _InvViewProjection;

static const float3 Axes[6] =
{
    float3(1.0f, 0.0f, 0.0f),
    float3(0.0f, 1.0f, 0.0f),
    float3(0.0f, 0.0f, 1.0f),
    float3(-1.0f, 0.0f, 0.0f),
    float3(0.0f, -1.0f, 0.0f),
    float3(0.0f, 0.0f, -1.0f),
};

// TODO: Rotate basis, to look at diagonals
static const half3x3 Basis[6] =
{
    // +X
    half3x3(
        0.0h, 0.0h, -1.0h,
        0.0h, 1.0h, 0.0h,
        1.0h, 0.0h, 0.0h
    ),
    // +Y
    half3x3(
        0.0h, 0.0h, -1.0h,
        -1.0h, 0.0h, 0.0h,
        0.0h, 1.0h, 0.0h
    ),
    // +Z
    half3x3(
        1.0h, 0.0h, 0.0h,
        0.0h, 1.0h, 0.0h,
        0.0h, 0.0h, 1.0h
    ),
    // -X
    half3x3(
        0.0h, 0.0h, 1.0h,
        0.0h, 1.0h, 0.0h,
        -1.0h, 0.0h, 0.0h
    ),
    // -Y
    half3x3(
        -1.0h, 0.0h, 0.0h,
        0.0h, 0.0h, -1.0h,
        0.0h, -1.0h, 0.0h
    ),
    // -Z
    half3x3(
        -1.0h, 0.0h, 0.0h,
        0.0h, 1.0h, 0.0h,
        0.0h, 0.0h, -1.0h
    ),
};

[numthreads(8,8,1)]
void RenderCascade(uint3 id : SV_DispatchThreadID)
{
    uint2 coords = id.xy;
    if (any(coords > _CascadeBufferSize.xy))
    {
        return;
    }

    float2 sideSize = _CascadeBufferSize.xy / float2(3, 2);
    float2 sideSizeRcp = float2(3, 2) * _CascadeBufferSize.zw;

    float2 probeCenterUV = (floor(fmod(coords, sideSize) / _ProbeSize) * _ProbeSize + 0.5f * _ProbeSize) * sideSizeRcp;

    int probeSide = dot(floor(coords / sideSize), float2(1, 3));
    float2 indexInProbe = floor(fmod(coords, _ProbeSize));

    float3 direction = float3(0.0f, 0.0f, 1.1f);
    // [0, 1, 2, 3] -> 4
    // [0..3] / (4 - 1) => [0..1] * 2 - 1 => [-1..1]
    if (_ProbeSize > 1.1f)
    {
        // [1..4] / (4 + 1)
        direction.xy += (indexInProbe + 1) / (_ProbeSize + 1.0f) * 2.0f - 1.0f;
    }
    direction = mul(Basis[probeSide], normalize(direction));

    // _OutCascade[coords] = float4(direction, 1);
    // return;

    float sceneDepth = SAMPLE_DEPTH_TEXTURE_LOD(_DepthTexture, sampler_PointClamp, probeCenterUV, 0);
    float3 positionWS = ComputeWorldSpacePosition(float4(probeCenterUV, sceneDepth, 1), _InvViewProjection);

    // BUG: Wrong camera forward vector!
    // positionWS += normalize(_View[2].xyz) * 0.1f;

    // BUG: Wrong offset, probably VP matrix is wrong, need to check!
    float3 viewDirectionWS = normalize(_WorldSpaceCameraPos.xyz - positionWS);
    positionWS += viewDirectionWS * 0.0001f;

    int2 cascadeRange = CalculateRange(_CascadeLevel);
    // _OutCascade[coords] = float4(cascadeRange.yyy < 0.001, 1);
    // return;

    float4 startUV = mul(_ViewProjection, float4(positionWS, 1));
    startUV.xyz /= startUV.w;

    // _OutCascade[coords] = float4(frac(startUV.xy), 0, 1);
    // return;

    float4 color = float4(0.0f, 0.0f, 0.0f, 1.0f);
    for (int i = cascadeRange.x; i < cascadeRange.y; i++)
    {
        float3 ray = positionWS + direction * i * 0.003f;

        float4 positionCS = mul(_ViewProjection, float4(ray, 1));
        positionCS.xyz /= positionCS.w;
        float2 screenUV = positionCS.xy;

        // _OutCascade[coords] = float4(frac(screenUV * 10), 0, 1);
        // _OutCascade[coords] = float4(frac(ray * 10), 1);

        // _OutCascade[coords] = float4(abs(startUV - screenUV) * 1000, 0, 1);
        // return;

        if (any(screenUV.xy < 0 || 1 < screenUV.xy)) break;

        float currentDepth = SAMPLE_DEPTH_TEXTURE_LOD(_DepthTexture, sampler_PointClamp, screenUV, 0);

        // _OutCascade[coords] = float4((currentDepth - positionCS).zzz > 0, 1);
        // return;

        if (currentDepth > positionCS.z) // INTERSECTION!
        {
            color = SAMPLE_TEXTURE2D_LOD(_ColorTexture, sampler_PointClamp, screenUV, 0);
            color.a = 0.0f;
            break;
        }
    }

    _OutCascade[coords] = color;
}


/////////////
/// MERGE ///
/////////////

float _LowerCascadeLevel;
Texture2D _UpperCascade;
RWTexture2D<float4> _LowerCascade;

static const int Cascade0Size = 1;

float4 AverageAngles(int2 topLeft)
{
    //       * | *
    // * => ---+---
    //       * | *
    float4 radiance = _UpperCascade[topLeft];
    radiance += _UpperCascade[topLeft + int2(1, 0)];
    radiance += _UpperCascade[topLeft + int2(0, 1)];
    radiance += _UpperCascade[topLeft + int2(1, 1)];
    radiance *= 0.25f;

    return radiance;
}

[numthreads(8,8,1)]
void MergeCascade(uint3 id : SV_DispatchThreadID)
{
    int2 coords = id.xy;
    if (any(coords > _CascadeBufferSize.xy))
    {
        return;
    }


    // Calculating dimensions
    int lowerCascadeDim = Cascade0Size * pow(2, _LowerCascadeLevel);
    int upperCascadeDim = Cascade0Size * pow(2, _LowerCascadeLevel + 1);

    int2 upperCoords = floor(coords / upperCascadeDim) * upperCascadeDim; // TODO: !!!
    float4 radiance = _LowerCascade[coords]; // Radiance from lower cascade

    //Calculate the position of the center of the lower probe
    int2 lowerCascadeIndex = floor(coords / lowerCascadeDim);
    int2 lowerCascadeCenterPos = lowerCascadeIndex * lowerCascadeDim + (lowerCascadeDim / 2);

    int2 upperCascadeIndex = floor((lowerCascadeIndex - 0.5) / 2.0);
    int2 upperCascadeOriginPos = upperCascadeIndex * upperCascadeDim;
    int2 upperCascadeCenterPos = upperCascadeOriginPos + upperCascadeDim * 0.5f;


    float4 a = AverageAngles(upperCoords);
    float4 b = AverageAngles(upperCoords + int2(upperCascadeDim, 0));
    float4 c = AverageAngles(upperCoords + int2(0, upperCascadeDim));
    float4 d = AverageAngles(upperCoords + int2(upperCascadeDim, upperCascadeDim));


    float2 weight = (lowerCascadeCenterPos - upperCascadeCenterPos) / float(upperCascadeDim);
    float4 m0 = lerp(a, b, weight.x);
    float4 m1 = lerp(c, d, weight.x);

    float4 upperRadiance = lerp(m0, m1, weight.y);

    radiance.rgb += upperRadiance.rgb * radiance.a;
    radiance.a *= upperRadiance.a;

    _LowerCascade[id.xy] = radiance;
}
