#pragma kernel RenderAndMergeCascade
#pragma kernel CombineSH

#include "Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SphericalHarmonics.hlsl"

// #define SIMPLE_RAYCASTING
#define SMALL_FLT 1e-6

// Input
float _RayScale;
int _CascadeLevel;
float2 _ProbesCount;
float2 _VarianceDepthSize;
float4x4 _InvProjectionMatrix;

Texture2D<float2> _MinMaxDepth;
Texture2D<float> _SmoothedDepth;
Texture2D<float2> _VarianceDepth;
Texture2D<float4> _BlurredColor;

/////////////
// Outputs //
/////////////

// Cascade Layout:
// Columns - longitudinal rays
// Rows - latitudinal rays
//            min probes                      max probes
// ._______________________________v_______________________________.
// |   ↗   |   ↖   |   ↙   |   ↘   |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|_______|_______|_______|_______|
// |   ↗   |   ↖   |   ↙   |   ↘   |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|_______|_______|_______|_______|
// |   ↗   |   ↖   |   ↙   |   ↘   |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|_______|_______|_______|_______|
// |   ↗   |   ↖   |   ↙   |   ↘   |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|_______|_______|_______|_______|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
RWTexture2D<float4> _RadianceCascades;

// Output
// ._____________.
// | SH0  | SH1x |
// |______|______|
// | SH1y | SH1z |
// |______|______|
RWTexture2D<float4> _RadianceSH;

static const int2 Ranges2[6] =
{
    int2(0, 1),
    int2(1, 2),
    int2(2, 4),
    int2(4, 8),
    int2(8, 16),
    int2(16, 32),
};

static const int2 Ranges4[6] =
{
    int2(0, 1),
    int2(1, 4),
    int2(4, 16),
    int2(16, 64),
    int2(64, 256),
    int2(256, 1024),
};

float3 TransformWorldToScreenSpace(float3 positionWS)
{
    float4 positionCS = TransformWorldToHClip(positionWS);
    positionCS.xyz /= positionCS.w;
    positionCS.xy = mad(positionCS.xy, float2(0.5f, -0.5f), float2(0.5f, 0.5f));
    return positionCS.xyz;
}

inline float2 TransformViewToScreenUV(float3 positionVS)
{
    float4 positionCS = mul(_ViewToHClip, float4(positionVS, 1));
    positionCS.xy /= positionCS.w;
    positionCS.xy = mad(positionCS.xy, float2(-0.5f, 0.5f), float2(0.5f, 0.5f));
    return positionCS.xyz;
}

float4 GetRadianceWeighted(int2 coords, float4 weights)
{
    float4 a = _RadianceCascades[coords];
    float4 b = _RadianceCascades[coords + int2(1, 0)];
    float4 c = _RadianceCascades[coords + int2(0, 1)];
    float4 d = _RadianceCascades[coords + int2(1, 1)];
    return a * weights.x
        + b * weights.y
        + c * weights.z
        + d * weights.w;
}

float4x4 LoadUpperCascadesBilinear(int2 coords, float4 weights)
{
    float4 a = _RadianceCascades[coords];
    float4 b = _RadianceCascades[coords + int2(1, 0)];
    float4 c = _RadianceCascades[coords + int2(0, 1)];
    float4 d = _RadianceCascades[coords + int2(1, 1)];
    return float4x4(
        a * weights.x,
        b * weights.y,
        c * weights.z,
        d * weights.w
    );
}

float2x4 LoadUpperRadianceBilateral(int2 coords, float2 lowerProbeDepth)
{
    const int2 upperCascadeSize = _ProbesCount * 0.5f;

    int2 lowerProbeId = coords % _ProbesCount;
    // | c | d |
    // |___|___|
    // |[a]| b |
    // |___|___|
    int2 upperProbeLocalId = clamp(floor((lowerProbeId - 1) * 0.5f), 0, upperCascadeSize - 2);

    float2 bilinearWeights = saturate(fmod((lowerProbeId - 1) * 0.5f, 1.0f) + 0.25f);
    float4 weights = float4(bilinearWeights, 1.0f - bilinearWeights);
    weights = float4(
        weights.z * weights.w,
        weights.x * weights.w,
        weights.z * weights.y,
        weights.x * weights.y
    );

    // 02----12----22----32----42----42
    // | D01 |     | E11 |     | F21 |
    // 02----12----22----32----42----42
    // |     |     |     |     |     |
    // 01----11----21----31----41----41
    // | A00 |     | B10 |     | C20 |
    // 00----10----20----30----40----40
    int2 upperCascadeCoords = floor(coords * 0.5f);
    upperCascadeCoords = floor(upperCascadeCoords / float2(upperCascadeSize)) * upperCascadeSize;
    upperCascadeCoords.x *= 2;
    upperCascadeCoords += upperProbeLocalId;
    upperCascadeCoords.y += upperCascadeSize.y * 4;

    // NOTE: Chebyshev Variance
    float2 uv = float2(lowerProbeId) / float2(_ProbesCount);
    float2 depthMoments = SAMPLE_TEXTURE2D_LOD(_VarianceDepth, sampler_PointClamp, uv, 0).rg;
    float smoothedDepth = depthMoments.x + sqrt(max(0.0, depthMoments.y - depthMoments.x * depthMoments.x));

    int depthLevel = _CascadeLevel + 3;
    static const int2 neighbours[4] = {int2(0, 0), int2(1, 0), int2(0, 1), int2(1, 1)};
    float2 weightedMinMaxDepth = 0.0f;
    for (int i = 0; i < 4; i++)
    {
        float2 minMaxDepth = LOAD_TEXTURE2D_LOD(_MinMaxDepth, upperProbeLocalId + neighbours[i], depthLevel);
        weightedMinMaxDepth += minMaxDepth * weights[i];
    }
    weightedMinMaxDepth = LinearEyeDepth(weightedMinMaxDepth, _ZBufferParams);
    float depthThickness = max(weightedMinMaxDepth.x - weightedMinMaxDepth.y, 0.0001f);

    float minProbeWeight = saturate((weightedMinMaxDepth[0] - lowerProbeDepth[0]) / depthThickness);
    float maxProbeWeight = saturate((weightedMinMaxDepth[0] - lowerProbeDepth[1]) / depthThickness);

    float2x4 radiance = 0.0f;

    int2 offset = int2(upperCascadeSize.x, 0);
    int halfCascadeBufferSizeX = floor(_CascadeBufferSize.x / 2);
    int2 neighbourRaysOffset[4] = {
        -offset + int2(halfCascadeBufferSizeX, 0) * (upperCascadeCoords.x < offset.x),
        int2(0, 0),
        offset,
        2 * offset - int2(halfCascadeBufferSizeX, 0) * (upperCascadeCoords.x + offset.x > halfCascadeBufferSizeX),
    };

    float4 minProbeRadiance = 0.0f;
    float4 maxProbeRadiance = 0.0f;
    for (int rayI = 0; rayI < 4; rayI++)
    {
        int2 off = neighbourRaysOffset[rayI];
        minProbeRadiance += GetRadianceWeighted(upperCascadeCoords + off, weights);
        maxProbeRadiance += GetRadianceWeighted(upperCascadeCoords + off + int2(halfCascadeBufferSizeX, 0), weights);
    }
    radiance[0] = lerp(minProbeRadiance, maxProbeRadiance, minProbeWeight);
    radiance[1] = lerp(minProbeRadiance, maxProbeRadiance, maxProbeWeight);

    return radiance;
}

float2 GetDepthMoments(float2 uv)
{
    return SAMPLE_TEXTURE2D_LOD(_VarianceDepth, sampler_LinearClamp, uv, _CascadeLevel).xy;
}

float3 GetSceneLighting(float2 uv)
{
    return SAMPLE_TEXTURE2D_LOD(_BlurredColor, sampler_LinearClamp, uv, _CascadeLevel).rgb;
}

#include "Raytracing.hlsl"

float4x4 TraceDepthRays(float3 probeCenterVS, float2 rayDirectionUV, int2 range)
{
    float cascadeExponent = 1u << _CascadeLevel;
    float4 outputSizeTexel = float4(_ProbesCount, 1.0f / _ProbesCount);
    half4x4 radiance = TraceDepthSector(
        probeCenterVS,
        rayDirectionUV,
        float2(range.x, range.y + 1),
        outputSizeTexel,
        cascadeExponent
    );
    return radiance;
}

[numthreads(8, 4, 1)]
void RenderAndMergeCascade(uint3 id : SV_DispatchThreadID)
{
    int2 coords = int2(id.xy);
    int2 targetCoords = int2(id.xy);
    targetCoords.y += _ProbesCount.y * 4;

    if (coords.x * 2 >= _CascadeBufferSize.x || coords.y >= _ProbesCount.y * 4)
    {
        return;
    }

    // BUG: Fix probe probeCenterUV?
    int2 probeCenterCoord = coords % _ProbesCount;
    float2 probeCenterUV = float2(probeCenterCoord + 0.5f) / _ProbesCount;

    const float cascadeLevel = _CascadeLevel;
    const int depthLevel = _CascadeLevel + 2;

    float3 rayDirectionVS;
    {
        // TODO: Fix hardcoded values.
        float cascadeFactor = pow(2.0f, cascadeLevel);
        float radialRaysCount = 8.0f * cascadeFactor;
        float angleId = floor(coords.x * radialRaysCount * _CascadeBufferSize.z);
        sincos((angleId.x + 0.5f) * TWO_PI / radialRaysCount, rayDirectionVS.y, rayDirectionVS.x);
        rayDirectionVS.z = 0;
    }

    float2 probeMinMaxDepth = LOAD_TEXTURE2D_LOD(_MinMaxDepth, probeCenterCoord, depthLevel).xy;
    float2 probeMinMaxDepthLinear = LinearEyeDepth(probeMinMaxDepth, _ZBufferParams);
    float4x4 minMaxRadiance[2];
    int2 range = Ranges4[_CascadeLevel];

    // TODO: Make two rays simultaneously!
    for (int probeDepthId = 0; probeDepthId < 2; probeDepthId++)
    {
        float3 probeCenterVS = ComputeViewSpacePosition(probeCenterUV, UNITY_RAW_FAR_CLIP_VALUE, _InvProjectionMatrix);
        probeCenterVS.xyz *= probeMinMaxDepthLinear[probeDepthId] / probeCenterVS.z;
        minMaxRadiance[probeDepthId] = TraceDepthRays(probeCenterVS, rayDirectionVS.xy, range);
    }

    if (_CascadeLevel < 5)
    {
        float radianceSectorSize = 0.25f / (1 << _CascadeLevel);
        for (int i = 0; i < 4; i++)
        {
            int2 coords0 = coords + int2(0, _ProbesCount.y * i);
            float2x4 upperRadiances = LoadUpperRadianceBilateral(coords0, probeMinMaxDepthLinear);

            float4 upperRadiance = upperRadiances[0];
            minMaxRadiance[0][i].rgb += upperRadiance.rgb * saturate(minMaxRadiance[0][i].a);
            minMaxRadiance[0][i].a *= saturate(upperRadiance.a);

            upperRadiance = upperRadiances[1];
            minMaxRadiance[1][i].rgb += upperRadiance.rgb * saturate(minMaxRadiance[1][i].a);
            minMaxRadiance[1][i].a *= saturate(upperRadiance.a);
        }
    }

    for (int i = 0; i < 4; i++)
    {
        int2 finalCoords = targetCoords + int2(0, _ProbesCount.y * i);
        _RadianceCascades[finalCoords] = minMaxRadiance[0][i]; // MinDepthProb
        _RadianceCascades[finalCoords + int2(_CascadeBufferSize.x / 2, 0)] = minMaxRadiance[1][i]; // MaxDepthProbe
    }
}


[numthreads(8, 4, 1)]
void CombineSH(uint3 id : SV_DispatchThreadID)
{
    int2 coords = id.xy;

    int2 upperCascadeSize = _ProbesCount * 0.5f;
    int2 lowerProbeId = coords % _ProbesCount;
    // | c | d |
    // |___|___|
    // |[a]| b |
    // |___|___|
    int2 upperProbeLocalId = clamp(floor((lowerProbeId - 1) * 0.5f), 0, upperCascadeSize - 2);

    float2 bilinearWeights = saturate(fmod((lowerProbeId - 1) * 0.5f, 1.0f) + 0.25f);
    float4 weights = float4(bilinearWeights, 1.0f - bilinearWeights);
    weights = float4(
        weights.z * weights.w,
        weights.x * weights.w,
        weights.z * weights.y,
        weights.x * weights.y
    );

    float2 weightedMinMaxDepth = 0.0f;
    for (uint i = 0; i < 4; i++)
    {
        int2 offset = int2(i % 2, i / 2);
        float2 minMaxDepth = LOAD_TEXTURE2D_LOD(_MinMaxDepth, upperProbeLocalId + offset, 2);
        weightedMinMaxDepth += minMaxDepth * weights[i];
    }
    weightedMinMaxDepth = LinearEyeDepth(weightedMinMaxDepth, _ZBufferParams);

    float2 minMaxDepth = LinearEyeDepth(LOAD_TEXTURE2D_LOD(_MinMaxDepth, coords, 1).xy, _ZBufferParams);
    float depthThickness = max(weightedMinMaxDepth.x - weightedMinMaxDepth.y, 0.001f);
    float depthOffset = saturate((weightedMinMaxDepth.x - minMaxDepth.x) / depthThickness);

    float4 sh0 = 0.0f;
    float4 sh1 = 0.0f;
    float4 sh2 = 0.0f;
    float4 sh3 = 0.0f;

    int2 upperCascadeCoords = upperProbeLocalId;
    upperCascadeCoords.y += upperCascadeSize.y * 7;
    
    for (int y = 0; y < 4; y++)
    {
        for (int x = 0; x < 4; x++)
        {
            // Sample radiance trilinear (uv, depth). 
            int2 upperCoords = upperCascadeCoords + int2(x, -y) * upperCascadeSize;
            float4 radianceMin = 0.0f;
            radianceMin += _RadianceCascades[upperCoords] * weights.x;
            radianceMin += _RadianceCascades[upperCoords + int2(1, 0)] * weights.y;
            radianceMin += _RadianceCascades[upperCoords + int2(0, 1)] * weights.z;
            radianceMin += _RadianceCascades[upperCoords + int2(1, 1)] * weights.w;

            upperCoords.x += 4 * upperCascadeSize.x;
            float4 radianceMax = 0.0f;
            radianceMax += _RadianceCascades[upperCoords] * weights.x;
            radianceMax += _RadianceCascades[upperCoords + int2(1, 0)] * weights.y;
            radianceMax += _RadianceCascades[upperCoords + int2(0, 1)] * weights.z;
            radianceMax += _RadianceCascades[upperCoords + int2(1, 1)] * weights.w;

            float4 radiance = lerp(radianceMin, radianceMax, depthOffset);

            float3 direction = GetRayDirectionDFWS(int2(x, y), 0);

            sh0 += radiance * kSHBasis0;
            sh1 += radiance * direction.x * kSHBasis1;
            sh2 += radiance * direction.y * kSHBasis1;
            sh3 += radiance * direction.z * kSHBasis1;
        }
    }

    _RadianceSH[coords + int2(0, 1) * _ProbesCount] = sh0;
    _RadianceSH[coords + int2(1, 1) * _ProbesCount] = sh1;
    _RadianceSH[coords + int2(0, 0) * _ProbesCount] = sh2;
    _RadianceSH[coords + int2(1, 0) * _ProbesCount] = sh3;
}
