#pragma kernel RenderAndMergeCascade
#pragma kernel CombineSH

#include "Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SphericalHarmonics.hlsl"

// #define SIMPLE_RAYCASTING
#define SMALL_FLT 1e-6

// Input
float _RayScale;
int _CascadeLevel;
float2 _ProbesCount;
float2 _VarianceDepthSize;
float4x4 _InvProjectionMatrix;

Texture2D<float2> _MinMaxDepth;
Texture2D<float> _SmoothedDepth;

SAMPLER(sampler_VarianceDepth);
Texture2D<float2> _VarianceDepth;
Texture2D<float4> _BlurredColor;

/////////////
// Outputs //
/////////////

// Cascade Layout:
// Columns - longitudinal rays
// Rows - latitudinal rays
//            min probes                      max probes
// ._______________________________v_______________________________.
// |   ↗   |   ↖   |   ↙   |   ↘   |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|_______|_______|_______|_______|
// |   ↗   |   ↖   |   ↙   |   ↘   |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|_______|_______|_______|_______|
// |   ↗   |   ↖   |   ↙   |   ↘   |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|_______|_______|_______|_______|
// |   ↗   |   ↖   |   ↙   |   ↘   |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|_______|_______|_______|_______|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
RWTexture2D<float4> _RadianceCascades;

// Output
// ._____________.
// | SH0  | SH1x |
// |______|______|
// | SH1y | SH1z |
// |______|______|
RWTexture2D<float4> _RadianceSH;

static const int2 Ranges2[6] =
{
    int2(0, 1),
    int2(1, 2),
    int2(2, 4),
    int2(4, 8),
    int2(8, 16),
    int2(16, 32),
};

static const int2 Ranges4[6] =
{
    int2(0, 1),
    int2(1, 4),
    int2(4, 16),
    int2(16, 64),
    int2(64, 256),
    int2(256, 1024),
};

float3 TransformWorldToScreenSpace(float3 positionWS)
{
    float4 positionCS = TransformWorldToHClip(positionWS);
    positionCS.xyz /= positionCS.w;
    positionCS.xy = mad(positionCS.xy, float2(0.5f, -0.5f), float2(0.5f, 0.5f));
    return positionCS.xyz;
}

inline float2 TransformViewToScreenUV(float3 positionVS)
{
    float4 positionCS = mul(_ViewToHClip, float4(positionVS, 1));
    positionCS.xy /= positionCS.w;
    positionCS.xy = mad(positionCS.xy, float2(-0.5f, 0.5f), float2(0.5f, 0.5f));
    return positionCS.xy;
}

float4 GetRadianceWeighted(int2 coords, float4 weights)
{
    float4 a = _RadianceCascades[coords];
    float4 b = _RadianceCascades[coords + int2(1, 0)];
    float4 c = _RadianceCascades[coords + int2(0, 1)];
    float4 d = _RadianceCascades[coords + int2(1, 1)];
    return a * weights.x
        + b * weights.y
        + c * weights.z
        + d * weights.w;
}

float4x4 LoadUpperCascadesBilinear(int2 coords, float4 weights)
{
    float4 a = _RadianceCascades[coords];
    float4 b = _RadianceCascades[coords + int2(1, 0)];
    float4 c = _RadianceCascades[coords + int2(0, 1)];
    float4 d = _RadianceCascades[coords + int2(1, 1)];
    return float4x4(
        a * weights.x,
        b * weights.y,
        c * weights.z,
        d * weights.w
    );
}

float2x4 LoadUpperRadianceBilateral(int2 coords, float2 lowerProbeDepth)
{
    const int2 upperCascadeSize = _ProbesCount * 0.5f;

    int2 lowerProbeId = coords % _ProbesCount;
    // | c | d |
    // |___|___|
    // |[a]| b |
    // |___|___|
    int2 upperProbeLocalId = clamp(floor((lowerProbeId - 1) * 0.5f), 0, upperCascadeSize - 2);

    float2 bilinearWeights = saturate(fmod((lowerProbeId - 1) * 0.5f, 1.0f) + 0.25f);
    float4 weights = float4(bilinearWeights, 1.0f - bilinearWeights);
    weights = float4(
        weights.z * weights.w,
        weights.x * weights.w,
        weights.z * weights.y,
        weights.x * weights.y
    );

    // 02----12----22----32----42----42
    // | D01 |     | E11 |     | F21 |
    // 02----12----22----32----42----42
    // |     |     |     |     |     |
    // 01----11----21----31----41----41
    // | A00 |     | B10 |     | C20 |
    // 00----10----20----30----40----40
    int2 upperCascadeCoords = floor(coords * 0.5f);
    upperCascadeCoords = floor(upperCascadeCoords / float2(upperCascadeSize)) * upperCascadeSize;
    upperCascadeCoords.x *= 2;
    upperCascadeCoords += upperProbeLocalId;
    upperCascadeCoords.y += upperCascadeSize.y * 4;

    // NOTE: Chebyshev Variance
    // float2 uv = float2(lowerProbeId) / float2(_ProbesCount);
    // float2 depthMoments = SAMPLE_TEXTURE2D_LOD(_VarianceDepth, sampler_PointClamp, uv, 0).rg;
    // float smoothedDepth = depthMoments.x + sqrt(max(0.0, depthMoments.y - depthMoments.x * depthMoments.x));

    int depthLevel = _CascadeLevel + 3;
    static const int2 neighbours[4] = {int2(0, 0), int2(1, 0), int2(0, 1), int2(1, 1)};
    float2 weightedMinMaxDepth = 0.0f;
    for (int i = 0; i < 4; i++)
    {
        float2 minMaxDepth = LOAD_TEXTURE2D_LOD(_MinMaxDepth, upperProbeLocalId + neighbours[i], depthLevel);
        weightedMinMaxDepth += minMaxDepth * weights[i];
    }
    weightedMinMaxDepth = LinearEyeDepth(weightedMinMaxDepth, _ZBufferParams);
    float depthThickness = max(weightedMinMaxDepth.x - weightedMinMaxDepth.y, 0.0001f);

    float minProbeWeight = saturate((weightedMinMaxDepth[0] - lowerProbeDepth[0]) / depthThickness);
    float maxProbeWeight = saturate((weightedMinMaxDepth[0] - lowerProbeDepth[1]) / depthThickness);

    float2x4 radiance = 0.0f;

    int2 offset = int2(upperCascadeSize.x, 0);
    int halfCascadeBufferSizeX = floor(_CascadeBufferSize.x / 2);
    int2 neighbourRaysOffset[4] = {
        -offset + int2(halfCascadeBufferSizeX, 0) * (upperCascadeCoords.x < offset.x),
        int2(0, 0),
        offset,
        2 * offset - int2(halfCascadeBufferSizeX, 0) * (upperCascadeCoords.x + offset.x > halfCascadeBufferSizeX),
    };

    float4 minProbeRadiance = 0.0f;
    float4 maxProbeRadiance = 0.0f;
    for (int rayI = 0; rayI < 4; rayI++)
    {
        int2 off = neighbourRaysOffset[rayI];
        minProbeRadiance += GetRadianceWeighted(upperCascadeCoords + off, weights);
        maxProbeRadiance += GetRadianceWeighted(upperCascadeCoords + off + int2(halfCascadeBufferSizeX, 0), weights);
    }
    radiance[0] = lerp(minProbeRadiance, maxProbeRadiance, minProbeWeight);
    radiance[1] = lerp(minProbeRadiance, maxProbeRadiance, maxProbeWeight);

    return radiance;
}

float2 GetDepthMoments(float2 uv)
{
    return SAMPLE_TEXTURE2D_LOD(_VarianceDepth, sampler_VarianceDepth, uv, _CascadeLevel + 2).xy;
}
float3 GetSceneLighting(float2 uv)
{
    return SAMPLE_TEXTURE2D_LOD(_BlurredColor, sampler_LinearClamp, uv, _CascadeLevel + 1).rgb;
}
#include "Raytracing.hlsl"

[numthreads(8, 4, 1)]
void RenderAndMergeCascade(uint3 id : SV_DispatchThreadID)
{
    int2 coords = int2(id.xy);
    int2 targetCoords = int2(id.xy);
    targetCoords.y += _ProbesCount.y * 4;

    if (coords.x * 2 >= _CascadeBufferSize.x || coords.y >= _ProbesCount.y * 4)
    {
        return;
    }

    // BUG: Fix probe probeCenterUV?
    int2 probeCenterCoord = coords % _ProbesCount;
    float2 probeCenterUV = float2(probeCenterCoord + 0.5) / _ProbesCount;

    const float cascadeLevel = _CascadeLevel;
    float2 probeMinMaxDepth = LOAD_TEXTURE2D_LOD(_MinMaxDepth, probeCenterCoord, _CascadeLevel + 2).xy;
    if (probeMinMaxDepth.y > _ProjectionParams.z * 0.95f)
    {
        for (int depthRayId = 0; depthRayId < 4; depthRayId++)
        {
            int2 finalCoords = targetCoords;
            finalCoords.y += _ProbesCount.y * (3 - depthRayId);
            _RadianceCascades[finalCoords] = float4(0,0,0,1); // MinDepthProb
            finalCoords.x += _CascadeBufferSize.x / 2;
            _RadianceCascades[finalCoords] = float4(0,0,0,1); // MaxDepthProbe
        }
        return;
    }

    float2 rayDirectionUV;
    {
        // TODO: Fix hardcoded values.
        float cascadeFactor = pow(2.0f, cascadeLevel);
        float radialRaysCount = 8.0f * cascadeFactor;
        float angleId = floor(coords.x * radialRaysCount * _CascadeBufferSize.z);

        float deltaPhi = TWO_PI * pow(0.5f, cascadeLevel) * 0.25f;
        sincos((angleId.x + 0.5f) * deltaPhi, rayDirectionUV.y, rayDirectionUV.x);
    }

    float4x4 minProbeRadiance;
    float4x4 maxProbeRadiance;

    int factor = 2;
    // int2 range = int2(_CascadeLevel * factor, (_CascadeLevel + 1) * factor + 2);
    int2 range = int2(0, (_CascadeLevel + 1) * factor);

    float4 outputSizeTexel = float4(_ProbesCount, 1.0f / _ProbesCount);
    float cascadeExponent = 1u << _CascadeLevel;
    ComputeProbeRadiance(
        probeMinMaxDepth,
        probeCenterUV,
        rayDirectionUV,
        range,
        outputSizeTexel,
        cascadeExponent,
        minProbeRadiance,
        maxProbeRadiance
    );

    if (_CascadeLevel < 5)
    {
        float radianceSectorSize = 1.0f / (1 << _CascadeLevel);
        UNITY_UNROLL
        for (int depthRayId = 0; depthRayId < 4; depthRayId++)
        {
            // TODO: Merge Depth Rays!
            int2 coords0 = coords + int2(0, _ProbesCount.y * depthRayId);
            float2x4 upperRadiances = LoadUpperRadianceBilateral(coords0, probeMinMaxDepth);

            float4 upperRadiance = upperRadiances[0];
            minProbeRadiance[depthRayId].rgb += upperRadiance.rgb * saturate(minProbeRadiance[depthRayId].a) * radianceSectorSize;
            minProbeRadiance[depthRayId].a *= upperRadiance.a;

            upperRadiance = upperRadiances[1];
            maxProbeRadiance[depthRayId].rgb += upperRadiance.rgb * saturate(maxProbeRadiance[depthRayId].a) * radianceSectorSize;
            maxProbeRadiance[depthRayId].a *= upperRadiance.a;
        }
    }

    for (int depthRayId = 0; depthRayId < 4; depthRayId++)
    {
        int2 finalCoords = targetCoords;
        finalCoords.y += _ProbesCount.y * (3 - depthRayId);
        _RadianceCascades[finalCoords] = minProbeRadiance[depthRayId]; // MinDepthProb
        finalCoords.x += _CascadeBufferSize.x / 2;
        _RadianceCascades[finalCoords] = maxProbeRadiance[depthRayId]; // MaxDepthProbe
    }
}


[numthreads(8, 4, 1)]
void CombineSH(uint3 id : SV_DispatchThreadID)
{
    int2 coords = id.xy;

    int2 upperCascadeSize = _ProbesCount * 0.5f;
    int2 lowerProbeId = coords % _ProbesCount;
    // | c | d |
    // |___|___|
    // |[a]| b |
    // |___|___|
    int2 upperProbeLocalId = clamp(floor((lowerProbeId - 1) * 0.5f), 0, upperCascadeSize - 2);

    float2 bilinearWeights = saturate(fmod((lowerProbeId - 1) * 0.5f, 1.0f) + 0.25f);
    float4 weights = float4(bilinearWeights, 1.0f - bilinearWeights);
    weights = float4(
        weights.z * weights.w,
        weights.x * weights.w,
        weights.z * weights.y,
        weights.x * weights.y
    );

    float2 weightedMinMaxDepth = 0.0f;
    for (uint i = 0; i < 4; i++)
    {
        int2 offset = int2(i % 2, i / 2);
        float2 minMaxDepth = LOAD_TEXTURE2D_LOD(_MinMaxDepth, upperProbeLocalId + offset, 2);
        weightedMinMaxDepth += minMaxDepth * weights[i];
    }
    weightedMinMaxDepth = LinearEyeDepth(weightedMinMaxDepth, _ZBufferParams);

    float2 minMaxDepth = LinearEyeDepth(LOAD_TEXTURE2D_LOD(_MinMaxDepth, coords, 1).xy, _ZBufferParams);
    float depthThickness = max(weightedMinMaxDepth.x - weightedMinMaxDepth.y, 0.00000001f);
    float depthOffset = saturate((weightedMinMaxDepth.x - minMaxDepth.x) / depthThickness);

    float4 sh0 = 0.0f;
    float4 sh1 = 0.0f;
    float4 sh2 = 0.0f;
    float4 sh3 = 0.0f;

    int2 upperCascadeCoords = upperProbeLocalId;
    upperCascadeCoords.y += upperCascadeSize.y * 7;
    
    for (int y = 0; y < 4; y++)
    {
        for (int x = 0; x < 4; x++)
        {
            // Sample radiance trilinear (uv, depth). 
            int2 upperCoords = upperCascadeCoords + int2(x, -y) * upperCascadeSize;
            float4 radianceMin = 0.0f;
            radianceMin += _RadianceCascades[upperCoords] * weights.x;
            radianceMin += _RadianceCascades[upperCoords + int2(1, 0)] * weights.y;
            radianceMin += _RadianceCascades[upperCoords + int2(0, 1)] * weights.z;
            radianceMin += _RadianceCascades[upperCoords + int2(1, 1)] * weights.w;

            upperCoords.x += 4 * upperCascadeSize.x;
            float4 radianceMax = 0.0f;
            radianceMax += _RadianceCascades[upperCoords] * weights.x;
            radianceMax += _RadianceCascades[upperCoords + int2(1, 0)] * weights.y;
            radianceMax += _RadianceCascades[upperCoords + int2(0, 1)] * weights.z;
            radianceMax += _RadianceCascades[upperCoords + int2(1, 1)] * weights.w;

            float4 radiance = lerp(radianceMin, radianceMax, depthOffset);

            float3 direction = normalize(GetRayDirectionDFWS(int2(x, y), 0));

            sh0 += radiance * kSHBasis0;
            sh1 += radiance * direction.x * kSHBasis1;
            sh2 += radiance * direction.y * kSHBasis1;
            sh3 += radiance * direction.z * kSHBasis1;
        }
    }

    _RadianceSH[coords + int2(0, 1) * _ProbesCount] = sh0;
    _RadianceSH[coords + int2(1, 1) * _ProbesCount] = sh1;
    _RadianceSH[coords + int2(0, 0) * _ProbesCount] = sh2;
    _RadianceSH[coords + int2(1, 0) * _ProbesCount] = sh3;
}
