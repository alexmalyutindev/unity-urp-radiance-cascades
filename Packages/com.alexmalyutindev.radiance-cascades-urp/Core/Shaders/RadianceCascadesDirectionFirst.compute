#pragma kernel RenderAndMergeCascade

#define _UPSCALE_MODE_BILATERAL

#include "Common.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/BRDF.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/GlobalIllumination.hlsl"

#define _LOAD_UPPER_CASCADE
#define _FOUR_RAYS_MERGE

// #define DEBUG
// #define USE_SMOOTHED_DEPTH

// Input
int _CascadeLevel;
int2 _ProbesCount;
float4x4 _WorldToView;
float4x4 _ViewToHClip;

Texture2D<float2> _MinMaxDepth;
Texture2D<float> _SmoothedDepth;
Texture2D<float2> _VarianceDepth;
Texture2D<float4> _BlurredColor;

// Output
RWTexture2D<float4> _OutCascade;

// Cascade Layout
// Rows - depth angled rays
// Columns - projection angled rays
// ._______________________________.
// |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|
// |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|
// |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|
// |   ↗   |   ↖   |   ↙   |   ↘   |
// |_______|_______|_______|_______|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|
// |_↗_|_↑_|_↖_|_←_|_↙_|_↓_|_↘_|_↗_|

static const int2 Ranges2[6] =
{
    int2(0, 1),
    int2(1, 4),
    int2(4, 16),
    int2(16, 64),
    int2(64, 256),
    int2(256, 1024),
};

static const int2 Ranges4[6] =
{
    int2(0, 4),
    int2(4, 16),
    int2(16, 64),
    int2(64, 256),
    int2(256, 1024),
    int2(1024, 2048),
};


float3 TransformWorldToScreenSpace(float3 positionWS)
{
    float4 positionCS = TransformWorldToHClip(positionWS);
    positionCS.xyz /= positionCS.w;
    positionCS.xy = mad(positionCS.xy, float2(0.5f, -0.5f), float2(0.5f, 0.5f));
    return positionCS.xyz;
}

inline float3 TransformViewToScreenSpace(float3 positionVS)
{
    float4 positionCS = mul(_ViewToHClip, float4(positionVS, 1));
    positionCS.xyz /= positionCS.w;
    positionCS.xy = mad(positionCS.xy, float2(0.5f, -0.5f), float2(0.5f, 0.5f));
    return positionCS.xyz;
}

float4 LoadUpperCascadeBilinear(int2 coords, float2 weights)
{
    float4 a = _OutCascade[coords];
    float4 b = _OutCascade[coords + int2(1, 0)];
    float4 c = _OutCascade[coords + int2(0, 1)];
    float4 d = _OutCascade[coords + int2(1, 1)];

    float4 e = lerp(a, b, weights.x);
    float4 f = lerp(c, d, weights.x);

    return lerp(e, f, weights.y);
}

inline float GetProbeDepth(float2 uv, int cascadeLevel)
{
    #ifdef USE_SMOOTHED_DEPTH

    float probeDepth = SAMPLE_TEXTURE2D_LOD(
        _SmoothedDepth,
        sampler_LinearClamp,
        uv,
        cascadeLevel + 0 // TODO: Calculate MipLevel depend on buffer resolution
    ).x;

    #if UNITY_REVERSED_Z
    probeDepth = 1.0f - probeDepth;
    #endif

    #else

    float probeDepth = SAMPLE_TEXTURE2D_LOD(
        _MinMaxDepth,
        sampler_PointClamp,
        uv,
        cascadeLevel
    ).y;

    #endif

    return probeDepth;
}

inline float4 LoadUpperRadiance(int2 coords)
{
    // TODO: Take into account probe positions to select more proper angled probes.
    const int2 lowerCascadeSize = _ProbesCount;
    const int2 upperCascadeSize = _ProbesCount * 0.5f;

    int2 upperCascadeCoords = floor(coords * 0.5f);

    // 02----12----22----32----42----42
    // | D01 |     | E11 |     | F21 |
    // 02----12----22----32----42----42
    // |     |     |     |     |     |
    // 01----11----21----31----41----41
    // | A00 |     | B10 |     | C20 |
    // 00----10----20----30----40----40

    int2 lowerProbeId = coords % lowerCascadeSize;
    int2 upperProbeBottomLeftId = clamp(floor((lowerProbeId - 1) * 0.5f), 0, upperCascadeSize - 2);
    float2 bilinearWeight = saturate(fmod((lowerProbeId - 1) * 0.5f, 1.0f) + 0.25f);

    upperCascadeCoords = upperCascadeCoords / upperCascadeSize * upperCascadeSize;
    upperCascadeCoords.x *= 2;
    upperCascadeCoords += upperProbeBottomLeftId;
    upperCascadeCoords.y += upperCascadeSize.y * 4;

    int2 offset = int2(upperCascadeSize.x, 0);

    float4 upperRadiance = 0.0f;

    // NOTE: Sample 2 main rays
    upperRadiance += LoadUpperCascadeBilinear(upperCascadeCoords, bilinearWeight);
    upperRadiance += LoadUpperCascadeBilinear(upperCascadeCoords + offset, bilinearWeight);

    #ifdef _FOUR_RAYS_MERGE
    // NOTE: Sample 2 secondary rays
    int2 secondaryUpperCascadeCoords = upperCascadeCoords - offset;
    secondaryUpperCascadeCoords.x += (secondaryUpperCascadeCoords.x < 0) * _CascadeBufferSize.x;
    upperRadiance += LoadUpperCascadeBilinear(secondaryUpperCascadeCoords, bilinearWeight);
    secondaryUpperCascadeCoords = upperCascadeCoords + 2 * offset;
    secondaryUpperCascadeCoords.x -= (secondaryUpperCascadeCoords.x > _CascadeBufferSize.x) * _CascadeBufferSize.x;
    upperRadiance += LoadUpperCascadeBilinear(secondaryUpperCascadeCoords, bilinearWeight);
    #endif

    #ifdef _FOUR_RAYS_MERGE
    upperRadiance *= 0.25f;
    #else
    upperRadiance *= 0.5f;
    #endif

    return upperRadiance;
}

// #define _UpsampleTolerance 1e-5f
// #define _NoiseFilterStrength 0.9999999f
float _UpsampleTolerance;
float _NoiseFilterStrength;

// The bilateral upscale function (2x2 neighborhood, color4 version)
float4 BilUpColor(
    float HiDepth,
    float4 LowDepths,
    float4 lowValue0, float4 lowValue1, float4 lowValue2, float4 lowValue3,
    float4 intialWeights
)
{
    float4 weights = intialWeights / (abs(HiDepth - LowDepths) + _UpsampleTolerance);
    float TotalWeight = dot(weights, 1) + _NoiseFilterStrength;
    float4 WeightedSum =
        lowValue0 * weights.x
        + lowValue1 * weights.y
        + lowValue2 * weights.z
        + lowValue3 * weights.w
        + _NoiseFilterStrength;
    return WeightedSum / TotalWeight;
}


float4 BilUpColor(
    float HiDepth,
    float4 LowDepths,
    float4x4 lowValues,
    float4 intialWeights
)
{
    float4 weights = intialWeights / (abs(HiDepth - LowDepths) + _UpsampleTolerance);
    float TotalWeight = dot(weights, 1) + _NoiseFilterStrength;
    float4 WeightedSum =
        lowValues[0] * weights.x
        + lowValues[1] * weights.y
        + lowValues[2] * weights.z
        + lowValues[3] * weights.w
        + _NoiseFilterStrength;
    return WeightedSum / TotalWeight;
}

float4 BilUpColor2(
    float4x4 lowValues,
    float4 intialWeights
)
{
    float4 weights = intialWeights;
    float TotalWeight = dot(weights, 1);
    float4 WeightedSum =
        lowValues[0] * weights.x
        + lowValues[1] * weights.y
        + lowValues[2] * weights.z
        + lowValues[3] * weights.w;
    return WeightedSum / TotalWeight;
}

float4 LoadUpperCascadeBilateral(
    int2 upperCascadeCoords,
    float2 bilinearWeights,
    float lowerCascadeDepth,
    float4 upperCascadeDepths
)
{
    float4x4 colors = float4x4(
        _OutCascade[upperCascadeCoords],
        _OutCascade[upperCascadeCoords + int2(1, 0)],
        _OutCascade[upperCascadeCoords + int2(0, 1)],
        _OutCascade[upperCascadeCoords + int2(1, 1)]
    );

    float4 w = float4(bilinearWeights, 1.0f - bilinearWeights);
    float4 weights = float4(
        w.z * w.w,
        w.x * w.w,
        w.z * w.y,
        w.x * w.y
    );

    return BilUpColor(
        lowerCascadeDepth,
        upperCascadeDepths,
        colors,
        weights * 9.0f
    );
}

float4 LoadUpperCascadeBilateral(int2 upperCascadeCoords, float4 weights)
{
    float4 a = _OutCascade[upperCascadeCoords];
    float4 b = _OutCascade[upperCascadeCoords + int2(1, 0)];
    float4 c = _OutCascade[upperCascadeCoords + int2(0, 1)];
    float4 d = _OutCascade[upperCascadeCoords + int2(1, 1)];
    return a * weights.x
        + b * weights.y
        + c * weights.z
        + d * weights.w;
}

float4x4 LoadUpperCascadesBilinear(int2 upperCascadeCoords, float4 weights)
{
    float4 a = _OutCascade[upperCascadeCoords];
    float4 b = _OutCascade[upperCascadeCoords + int2(1, 0)];
    float4 c = _OutCascade[upperCascadeCoords + int2(0, 1)];
    float4 d = _OutCascade[upperCascadeCoords + int2(1, 1)];
    return float4x4(
        a * weights.x,
        b * weights.y,
        c * weights.z,
        d * weights.w
    );
}

float2x4 LoadUpperCascadeBilateral(
    int2 upperCascadeCoords,
    float4 weights,
    float4 depthWeightMin,
    float4 depthWeightMax
)
{
    float4x4 upperRadiance = LoadUpperCascadesBilinear(upperCascadeCoords, weights);
    return float2x4(
        mul(depthWeightMin, upperRadiance),
        mul(depthWeightMax, upperRadiance)
    );
}

float2 LinearEyeDepth(float2 depth, float4 zBufferParam)
{
    return 1.0f / (zBufferParam.z * depth + zBufferParam.w);
}

float4 LinearEyeDepth(float4 depth, float4 zBufferParam)
{
    return 1.0f / (zBufferParam.z * depth + zBufferParam.w);
}

float2x4 LoadUpperRadianceBilateral(int2 coords, float2 lowerProbeDepth)
{
    const int2 upperCascadeSize = _ProbesCount * 0.5f;

    int2 lowerProbeId = coords % _ProbesCount;
    // | c | d |
    // |___|___|
    // |[a]| b |
    // |___|___|
    int2 upperProbeLocalId = clamp(floor((lowerProbeId - 1) * 0.5f), 0, upperCascadeSize - 2);

    float2 bilinearWeights = saturate(fmod((lowerProbeId - 1) * 0.5f, 1.0f) + 0.25f);
    float4 weights = float4(bilinearWeights, 1.0f - bilinearWeights);
    weights = float4(
        weights.z * weights.w,
        weights.x * weights.w,
        weights.z * weights.y,
        weights.x * weights.y
    );

    int2 upperCascadeCoords = floor(coords * 0.5f);

    // 02----12----22----32----42----42
    // | D01 |     | E11 |     | F21 |
    // 02----12----22----32----42----42
    // |     |     |     |     |     |
    // 01----11----21----31----41----41
    // | A00 |     | B10 |     | C20 |
    // 00----10----20----30----40----40

    upperCascadeCoords = upperCascadeCoords / upperCascadeSize * upperCascadeSize;
    upperCascadeCoords.x *= 2;
    upperCascadeCoords += upperProbeLocalId;
    upperCascadeCoords.y += upperCascadeSize.y * 4;

    int2 offset = int2(upperCascadeSize.x, 0);

    // NOTE: Chebyshev Variance
    float2 depthMoments = SAMPLE_TEXTURE2D_LOD(
        _VarianceDepth, sampler_PointClamp, float2(lowerProbeId) / float2(_ProbesCount), 0
    ).rg;
    float smoothedDepth = depthMoments.x + sqrt(max(0.0, depthMoments.y - depthMoments.x * depthMoments.x));

    // BUG: This is 0 for Cascade0! Calculate depthThikness using upper MinMaxDepth.
    // float depthThickness = abs(lowerProbeDepth.x - lowerProbeDepth.y) * 0.5f;

    float2 upperDepthA = LOAD_TEXTURE2D_LOD(_MinMaxDepth, upperProbeLocalId, _CascadeLevel + 1);
    float2 upperDepthB = LOAD_TEXTURE2D_LOD(_MinMaxDepth, upperProbeLocalId + int2(1, 0), _CascadeLevel + 1);
    float2 upperDepthC = LOAD_TEXTURE2D_LOD(_MinMaxDepth, upperProbeLocalId + int2(0, 1), _CascadeLevel + 1);
    float2 upperDepthD = LOAD_TEXTURE2D_LOD(_MinMaxDepth, upperProbeLocalId + int2(1, 1), _CascadeLevel + 1);

    float2 avgDepth = float2(
        min(upperDepthA.x, min(upperDepthB.x, min(upperDepthC.x, upperDepthD.x))),
        max(upperDepthA.y, max(upperDepthB.y, max(upperDepthC.y, upperDepthD.y)))
    );
    avgDepth = LinearEyeDepth(avgDepth, _ZBufferParams);
    // BUG: If depthThickness too small it will lead to NaNs.
    float depthThickness = max(abs(avgDepth.x - avgDepth.y) * 0.5f, 0.01f);

    float4 depthWeightsMin = saturate(1.0f - (abs(lowerProbeDepth[0] - smoothedDepth) + 0.00001f) / depthThickness);
    depthWeightsMin /= dot(depthWeightsMin + 0.00001f, 1.0f);

    float4 depthWeightsMax = saturate(1.0f - (abs(lowerProbeDepth[1] - smoothedDepth) + 0.00001f) / depthThickness);
    depthWeightsMax /= dot(depthWeightsMax + 0.00001f, 1.0f);

    float2x4 radiance = 0.0f;
    // TODO: Calculate pair: of upper radiance, on with weight for Min probe, and other for Max probe.
    radiance += LoadUpperCascadeBilateral(upperCascadeCoords, weights, depthWeightsMin, depthWeightsMax);
    radiance += LoadUpperCascadeBilateral(upperCascadeCoords + offset, weights, depthWeightsMin, depthWeightsMax);
    // return radiance * 0.5f;

    int2 secondaryUpperCascadeCoords = upperCascadeCoords - offset;
    secondaryUpperCascadeCoords.x += (secondaryUpperCascadeCoords.x < 0) * _CascadeBufferSize.x;
    radiance += LoadUpperCascadeBilateral(secondaryUpperCascadeCoords, weights, depthWeightsMin, depthWeightsMax);

    secondaryUpperCascadeCoords = upperCascadeCoords + 2 * offset;
    secondaryUpperCascadeCoords.x -= (secondaryUpperCascadeCoords.x > _CascadeBufferSize.x) * _CascadeBufferSize.x;
    radiance += LoadUpperCascadeBilateral(secondaryUpperCascadeCoords, weights, depthWeightsMin, depthWeightsMax);

    return radiance * 0.25f;
}

[numthreads(8, 4, 1)]
void RenderAndMergeCascade(uint3 id : SV_DispatchThreadID)
{
    const float RayScale = 0.2f;

    int2 coords = int2(id.xy);
    int2 targetCoords = int2(id.xy);
    targetCoords.y += _ProbesCount.y * 4;

    if (coords.x >= _CascadeBufferSize.x || coords.y >= _ProbesCount.y * 4)
    {
        return;
    }

    // BUG: Fix probe probeCenterUV!
    int2 probeCenterCoord = coords % _ProbesCount;
    float2 probeCenterUV = float2(probeCenterCoord + 1.0f) / (_ProbesCount + 1.0f);

    const float cascadeLevel = _CascadeLevel;

    float3 directionWS;
    {
        float cascadeFactor = pow(2.0f, cascadeLevel);
        float projRays = 8.0f * cascadeFactor;
        float depthRays = floor(4.0f * cascadeFactor * 2.0f);
        float2 angleId;

        angleId.x = floor(coords.x * projRays * _CascadeBufferSize.z);
        angleId.y = fmod(floor((1.0f - (coords.y + 1) * _CascadeBufferSize.w) * depthRays), 4);

        directionWS = GetRay_DirectionFirst(angleId, cascadeLevel);
    }

    float2 probeMinMaxDepth = LOAD_TEXTURE2D_LOD(_MinMaxDepth, probeCenterCoord, cascadeLevel);
    float2 probeMinMaxDepthLinear = LinearEyeDepth(probeMinMaxDepth, _ZBufferParams);
    float4 radiance[2];
    radiance[0] = float4(0.0f, 0.0f, 0.0f, 1.0f);
    radiance[1] = float4(0.0f, 0.0f, 0.0f, 1.0f);
    int2 range = Ranges2[cascadeLevel];

    // TODO: Make two rays simultaneously!
    for (int probeDepthId = 0; probeDepthId < 2; probeDepthId++)
    {
        if (probeMinMaxDepthLinear[probeDepthId] > 500.0f) // Probe is too far, skip it.
        {
            // NOTE: Skip probe that placed on skybox.
            radiance[0] = float4(0.0f, 0.0f, 0.0f, 1.0f);
            continue;
        }

        // Raytracing
        float3 probeCenterWS = GetPositionWS(probeCenterUV, probeMinMaxDepth[probeDepthId]);
        float3 viewDirectionWS = normalize(probeCenterWS - _WorldSpaceCameraPos);
        probeCenterWS -= viewDirectionWS * 0.02f;

        float3 rayOriginWS = probeCenterWS + directionWS * RayScale * range.x;
        float3 rayEndWS = probeCenterWS + directionWS * RayScale * range.y;

        float3 rayOriginVS = mul(_WorldToView, float4(rayOriginWS, 1)).xyz;
        float3 rayEndVS = mul(_WorldToView, float4(rayEndWS, 1)).xyz;

        float stepsCount = 2 << _CascadeLevel + 1;

        UNITY_LOOP
        for (int i = 0; i < stepsCount; i++)
        {
            // TODO: Use DDA for ray marching.
            float3 rayVS = lerp(rayOriginVS, rayEndVS, i / (stepsCount - 1.0f));
            float3 ray = TransformViewToScreenSpace(rayVS);
            if (any(ray.xy < 0 || 1 < ray.xy))
            {
                break;
            }

            float2 minMaxDepth = LOAD_TEXTURE2D_LOD(
                _MinMaxDepth,
                floor(ray.xy * _ProbesCount),
                cascadeLevel
            ).xy;

            // TODO: Use MinMax compare on lower mips and go up if collide.
            float depth = minMaxDepth[probeDepthId];

            float linearDepth = LinearEyeDepth(depth, _ZBufferParams);
            bool test = linearDepth < -rayVS.z && linearDepth > -(rayVS.z + 2.25f);

            // TODO: Compare depth rays.
            // TODO: Add ray distance fading.
            if (test)
            {
                // TODO: Calculate MipLevel depend on resolution!
                radiance[probeDepthId].rgb = SAMPLE_TEXTURE2D_LOD(
                    _BlurredColor,
                    sampler_LinearClamp,
                    ray.xy,
                    cascadeLevel
                ).rgb;
                radiance[probeDepthId].a = 0.0f;
                break;
            }
        }
    }

    if (cascadeLevel < 5)
    {
        #if defined(_UPSCALE_MODE_BILATERAL)

        float2x4 upperRadiances = LoadUpperRadianceBilateral(coords, probeMinMaxDepthLinear);

        float4 upperRadiance = upperRadiances[0];
        radiance[0].rgb += upperRadiance.rgb * radiance[0].a;
        radiance[0].a *= upperRadiance.a;

        upperRadiance = upperRadiances[1];
        radiance[1].rgb += upperRadiance.rgb * radiance[1].a;
        radiance[1].a *= upperRadiance.a;

        #else
        float4 upperRadiance = LoadUpperRadiance(coords);
        radiance[0].rgb += upperRadiance.rgb * radiance[0].a;
        radiance[0].a *= upperRadiance.a;
        #endif
    }

    _OutCascade[targetCoords] = radiance[0] + radiance[1];
}
