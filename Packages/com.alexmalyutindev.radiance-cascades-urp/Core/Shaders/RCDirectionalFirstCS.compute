#pragma kernel RenderCascade
#pragma kernel MergeCascade

#include "Common.hlsl"

float _ProbeSize;
RWTexture2D<float4> _OutCascade;

// Cascade Layout
// Rows - depth angled rays
// Columns - projection angled rays
// ._______________________________.
// |   ⬈   |   ⬉   |   ⬋   |   ⬊   |
// |_______|_______|_______|_______|
// |   ⬈   |   ⬉   |   ⬋   |   ⬊   |
// |_______|_______|_______|_______|
// |   ⬈   |   ⬉   |   ⬋   |   ⬊   |
// |_______|_______|_______|_______|
// |   ⬈   |   ⬉   |   ⬋   |   ⬊   |
// |_______|_______|_______|_______|

[numthreads(8,8,1)]
void RenderCascade(uint3 id : SV_DispatchThreadID)
{
    uint2 coords = id.xy;
    if (any(coords > uint2(_CascadeBufferSize.xy)))
    {
        return;
    }

    float cascadeLevel = coords.y * _CascadeBufferSize.w;
    cascadeLevel = floor(-log2(cascadeLevel));
    if (cascadeLevel > 5) return;

    float cascadeFactor = pow(2.0f, cascadeLevel);
    float projRays = 8.0f * cascadeFactor;
    const float depthRays = 4.0f * cascadeFactor * 2.0f;

    // NOTE: 8 in projection x4 rays in depth in Cascade0
    float deltaAngle = TWO_PI * pow(0.5f, cascadeLevel) * 0.125f; // 1/8
    float2 angleId = floor(coords * _CascadeBufferSize.zw * float2(projRays, depthRays));
    float angleX = (angleId.x + 0.5f) * deltaAngle;


    // TODO: Remove separate thread to depth rays, cast 4 rays in one thread.
    if (angleId.y % 4.0f < 2.5f)
    {
        // _OutCascade[coords] = float4(0, 0.5f, 0.0f, 1.0f);
        // return;
    }

    // TODO: Depth rays angle!
    // TODO: I can spawn less threads, cus depth rays can be done in simultaneously (one pixel in depth buffer)
    // and then i should write then into four pixels in cascade. Potentially, it should reduce time by 4.
    float angleD = (angleId.y - 1.5f) * HALF_PI * 0.25f;

    float2 direction;
    sincos(angleX, direction.y, direction.x);
    direction *= _ColorTexture_TexelSize.xy;

    float2 uv = frac(coords * _CascadeBufferSize.zw * float2(projRays, depthRays));
    float depth0 = SAMPLE_DEPTH_TEXTURE_LOD(_DepthTexture, sampler_PointClamp, uv, 0) + 0.001f;
    float depth0Thick = depth0 + 0.2f;

    float4 color = float4(0, 0, 0, 1);
    int2 range = CalculateRange(cascadeLevel);
    UNITY_LOOP
    for (int i = range.x; i <= range.y; i++)
    {
        float depth = SAMPLE_DEPTH_TEXTURE_LOD(_DepthTexture, sampler_PointClamp, uv + direction * i, 0);

        // TODO: Compare depth for 4 depth rays.
        // To find ray.z in ClipSpace i should transform it in ViewSpace then add needed component
        // I need to compensate perspective distortion. Rays shot in camera direction will be smaller
        // than ray out of camera.
        if (depth0 < depth && depth < depth0Thick)
        {
            color = SAMPLE_TEXTURE2D_LOD(_ColorTexture, sampler_LinearClamp, uv + direction * i, 0);
            color.a = 0.0f;
            break;
        }
    }

    // color += float4(0, cascadeLevel * 0.1f, id.x * _CascadeBufferSize.z, 0);
    _OutCascade[coords] = color;
}


// UpperCascadeLevel
float _CascadeLevel;
RWTexture2D<float4> _LowerCascade;
Texture2D<float4> _UpperCascade;

float4 SampleUpperCascade(int2 coords)
{
    // TODO: Bilinear interpolate 2x2 probes
    float4 radiance = SAMPLE_TEXTURE2D_LOD(
        _UpperCascade,
        sampler_LinearClamp,
        (coords + 1.0f) * _CascadeBufferSize.zw, 0
    );
    return radiance;
}

[numthreads(8,8,1)]
void MergeCascade(uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy * _CascadeBufferSize.zw;

    // TODO: Move this staff to the CPU side
    float lowerCascadeTop = pow(2, -_CascadeLevel);
    float upperCascadeTop = pow(2, -(_CascadeLevel + 1));

    int2 lowerCoords = id.xy + int2(0, lowerCascadeTop * _CascadeBufferSize.y);

    const float anglesCount = 8 * pow(2, _CascadeLevel - 1);
    float probesCountX = floor(_CascadeBufferSize.x / anglesCount * 0.5f);

    // TODO: This /2 is subpixel for bilinear sampling of UpperCascade
    // TODO: Rework upper cascade coords with normalized UV coords
    int2 upperCoordsLeft = int2(
        id.x / 2 + probesCountX * floor(uv.x * anglesCount),
        id.y / 2 + upperCascadeTop * _CascadeBufferSize.y
    );
    int2 upperCoordsRight = upperCoordsLeft + int2(probesCountX, 0);

    float4 radiance = _LowerCascade[lowerCoords];
    if (radiance.a < 0.5f) return;
    
    float4 upperRadianceLeft = SampleUpperCascade(upperCoordsLeft);
    float4 upperRadianceRight = SampleUpperCascade(upperCoordsRight);

    float4 upperRadiance = (upperRadianceLeft + upperRadianceRight) * 0.5f;

    radiance.rgb += upperRadiance.rgb * radiance.a;
    radiance.a *= upperRadiance.a;

    _LowerCascade[lowerCoords] = radiance;
}
